
use rand::rngs::SmallRng;
use rand::RngCore;
use rand::SeedableRng;
use std::fs::File;
use std::io::Write;

use crate::position::{Piece, Side, Step};

const NUM_PIECES: usize = 12; // Empty is not counted
const NUM_SQUARES: usize = 64;

include!("table_zobrist.rs");

pub fn compute_hash(board: &[Piece; 64], side: Side) -> u64 {
    let mut hash = 0;
    for (square, p) in board.iter().enumerate() {
        let p = *p as usize;
        if p != 0 {
            hash ^= get_zobrist(square, p);
        }
    }
    match side {
        Side::White => hash ^= SIDE_TO_MOVE[0],
        Side::Black => hash ^= SIDE_TO_MOVE[1],
    }
    hash
}
pub fn update_hash(mut hash: u64, step: Step) -> u64 {
    match step {
        Step::Move(p, source, dest) | Step::Push(p, source, dest) => {
            let pix = (p as usize) - 1;
            hash ^= get_zobrist(source as usize, pix); // xor out
            hash ^= get_zobrist(dest as usize, pix); // xor in
        }
        Step::Place(p, sq) | Step::Remove(p, sq) => {
            let pix = (p as usize) - 1;
            hash ^= get_zobrist(sq as usize, pix); // xor in / out
        }
        _ => {}
    }
    hash
}
pub fn color_hash(color: Side) -> u64 {
    match color {
        Side::White => SIDE_TO_MOVE[0],
        Side::Black => SIDE_TO_MOVE[1],
    }
}
fn get_zobrist(sq: usize, piece: usize) -> u64 {
    //unimplemented!()
    ZOBRIST_PIECES[sq][piece]
}

pub fn write_zobrist(f: &mut File) {
    let mut rng = SmallRng::seed_from_u64(0xDEADBEEF);

    write!(f, "/// Autogenerated by zobrist.rs\n").unwrap();

    write!(
        f,
        "const SIDE_TO_MOVE: [u64; 2] = [{}, {}];\n\n",
        rng.next_u64(),
        rng.next_u64()
    )
    .unwrap();

    write!(
        f,
        "const STEPS_LEFT: [u64; 4] = [{}, {}, {}, {}];\n\n",
        rng.next_u64(),
        rng.next_u64(),
        rng.next_u64(),
        rng.next_u64()
    )
    .unwrap();

    write!(
        f,
        "const ZOBRIST_PIECES: [[u64; NUM_SQUARES]; NUM_PIECES] = [[\n"
    )
    .unwrap();
    for j in 0..NUM_PIECES {
        for _ in 0..NUM_SQUARES {
            write!(f, "    {},\n", rng.next_u64()).unwrap();
        }
        if j != NUM_PIECES - 1 {
            write!(f, "   ], [\n").unwrap();
        }
    }
    write!(f, "]];\n\n").unwrap();
}